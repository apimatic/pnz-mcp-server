/**
 * Account and Transaction API SpecificationLib
 *
 * This file was automatically generated by APIMATIC v3.0 ( https://www.apimatic.io ).
 */

import { Ajv } from 'ajv';
import addFormats from "ajv-formats";
import EndpointSchemas from './schemaData.json' with { type: "json" };
import { ErrorCode, McpError } from '@modelcontextprotocol/sdk/types.js';
import { stringifyRawJson } from './utils.js';
import { $RefParser } from '@apidevtools/json-schema-ref-parser';
import { dirname, sep } from 'node:path';
import { fileURLToPath } from 'node:url';

const currentDir = dirname(fileURLToPath(import.meta.url)) + sep;
const parser = new $RefParser();

type Schema = {
    type: "object",
    properties?: Record<string, unknown>,
    required?: string[]
}

type ToolError = {
    type: "text",
    text: string
}

type ValidationSummary = {
    isValid: boolean,
    errors?: ToolError[]
}

class Schemas {
    private readonly endpointSchemas = EndpointSchemas;
    private readonly ajv = addFormats.default(new Ajv({allErrors: true}));

    async loadSchema(endpointGroup: string, endpointName: string): Promise<Schema> {

        const { properties: props, required: requiredProps } = this.endpointSchemas.endpoints.find(
            (endpoint) => endpoint.group === endpointGroup && endpoint.name === endpointName
        )?.schema.properties.args ?? {};

        const schema = {
            type: "object" as const,
            properties: props,
            required: requiredProps,
        };

        await parser.bundle(`${currentDir}`, schema, {mutateInputSchema: true});

        this.ajv.addSchema(schema, `${endpointGroup}-${endpointName}`);

        return schema;
    }

    validate(value: unknown, endpointGroup: string, endpointName: string): ValidationSummary {
        const validateFunc = this.ajv.getSchema(`${endpointGroup}-${endpointName}`);
        if (!validateFunc){
            throw new McpError(
                  ErrorCode.InternalError,
                  "Schema must be loaded before validation is used."
                );
        }

        if (validateFunc(value)){
            return {
                isValid: true,
            }
        } else if (validateFunc.errors){
            console.error(validateFunc.errors)
            return {
                isValid: false,
                errors: validateFunc.errors.map((err) => ({ type: "text" as const, text: stringifyRawJson(err) }))
            }
        } else {
            return {
                isValid: false
            }
        }
    }
}

export const schemas = new Schemas();